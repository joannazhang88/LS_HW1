# -*- coding: utf-8 -*-
"""HW1Q3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TY49epXypn4i5T4e9dSlu_pknhMhktuy
"""

#! pip install mpi4py
#! mpirun --allow-run-as-root -n 4 python mpi_rand_walk.py

import numpy as np
from sklearn.model_selection import GridSearchCV
from sklearn.linear_model import Ridge
import time
import scipy.stats as sts

def avglen(rho, N):
  negative = np.full(N,fill_value = T)
  for s_ind in range(N):
        z_tm1 = z_0
        for t_ind in range(T):
            e_t = eps_mat[s_ind, t_ind]
            z_t = rho * z_tm1 + (1 - rho) * mu + e_t
            z_mat[s_ind, t_ind] = z_t
            z_tm1 = z_t
            if z_tm1<0:
              negative[N] = t_ind  
  return np.average(negative)

def gs_rho():
  comm = MPI.COMM_WORLD
  rank = comm.Get_rank()
  size = comm.Get_size()
  t0 = time.time()
  S=1
  T=10
  mu = 3
  z_0 = mu
  np.random.seed(25)
  rhos = np.linspace(-0.95, 0.95, num=200)
  sim_avg = np.zeros(200)

  N = int(S/size)
  eps_mat = sts.norm.rvs(loc=0, scale=sigma, size=(N, T))
  z_mat = np.zeros((N, T))
  z_mat[0, :] = z_0

  negative = np.full(N,fill_value = T)
  for s_ind in range(N):
        z_tm1 = z_0
        for t_ind in range(T):
            e_t = eps_mat[s_ind, t_ind]
            z_t = rho * z_tm1 + (1 - rho) * mu + e_t
            z_mat[s_ind, t_ind] = z_t
            z_tm1 = z_t
            if z_tm1<0:
              negative[N] = t_ind
              break  

  neg_indx_all = none
  if rank == 0:
    neg_indx_all = np.empty((N*size), dtype='float')
  comm.Gather(sendbuf = negative, recvbuf = neg_indx_all, root=0)

  print(neg_indx_all)




  #for i in range(length(sim_avg)):
    #print(avglen(rho, N))
    #sim_avg[i] = avglen(rho, N)

def main():
    gs_rho()

if __name__ == '__main__':
    main()